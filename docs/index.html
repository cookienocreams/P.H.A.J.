<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>P.H.A.J. · P.H.A.J. Documentation</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>P.H.A.J. Documentation</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>P.H.A.J.</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>P.H.A.J.</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>P.H.A.J.</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="P.H.A.J."><a class="docs-heading-anchor" href="#P.H.A.J.">P.H.A.J.</a><a id="P.H.A.J.-1"></a><a class="docs-heading-anchor-permalink" href="#P.H.A.J." title="Permalink"></a></h1><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Phaj.Region"><code>Phaj.Region</code></a></li><li><a href="#Phaj.nn_params"><code>Phaj.nn_params</code></a></li><li><a href="#Phaj.build_longest_common_prefix"><code>Phaj.build_longest_common_prefix</code></a></li><li><a href="#Phaj.build_suffix_array"><code>Phaj.build_suffix_array</code></a></li><li><a href="#Phaj.calculate_thermodynamic_parameters"><code>Phaj.calculate_thermodynamic_parameters</code></a></li><li><a href="#Phaj.check_probe_tm"><code>Phaj.check_probe_tm</code></a></li><li><a href="#Phaj.filter_probes"><code>Phaj.filter_probes</code></a></li><li><a href="#Phaj.find_homodimers"><code>Phaj.find_homodimers</code></a></li><li><a href="#Phaj.gc_content"><code>Phaj.gc_content</code></a></li><li><a href="#Phaj.longest_aligned_region!"><code>Phaj.longest_aligned_region!</code></a></li><li><a href="#Phaj.parse_commandline"><code>Phaj.parse_commandline</code></a></li><li><a href="#Phaj.probe_tm_salt_correction"><code>Phaj.probe_tm_salt_correction</code></a></li><li><a href="#Phaj.progress_bar_update"><code>Phaj.progress_bar_update</code></a></li><li><a href="#Phaj.prpy_sequence"><code>Phaj.prpy_sequence</code></a></li><li><a href="#Phaj.sequence_thermodynamic_sum"><code>Phaj.sequence_thermodynamic_sum</code></a></li><li><a href="#Phaj.slice_probe"><code>Phaj.slice_probe</code></a></li><li><a href="#Phaj.sortbyrank"><code>Phaj.sortbyrank</code></a></li></ul><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><p>Documentation for Phaj.jl</p><article class="docstring"><header><a class="docstring-binding" id="Phaj.nn_params" href="#Phaj.nn_params"><code>Phaj.nn_params</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">nn_params</code></pre><p>A structure encapsulating the thermodynamic parameters for DNA nearest-neighbor (NN) interactions. </p><p>The values are based on SantaLucia&#39;s 1997 paper titled  &quot;Thermodynamics and NMR of internal G·T mismatches in DNA.&quot;  <a href="https://doi.org/10.1021/bi962590c">DOI</a>.</p><p><strong>Parameters</strong></p><p>The struct contains entropy (ΔS, in cal/mol·K) and enthalpy (ΔH, in kcal/mol) values for  each of the NN pairs:</p><table><tr><th style="text-align: center">NN Pair</th><th style="text-align: center">ΔS</th><th style="text-align: center">ΔH</th></tr><tr><td style="text-align: center">AA</td><td style="text-align: center">delta_s</td><td style="text-align: center">delta_h</td></tr><tr><td style="text-align: center">AC</td><td style="text-align: center">delta_s</td><td style="text-align: center">delta_h</td></tr><tr><td style="text-align: center">AG</td><td style="text-align: center">delta_s</td><td style="text-align: center">delta_h</td></tr><tr><td style="text-align: center">AT</td><td style="text-align: center">delta_s</td><td style="text-align: center">delta_h</td></tr><tr><td style="text-align: center">CA</td><td style="text-align: center">delta_s</td><td style="text-align: center">delta_h</td></tr><tr><td style="text-align: center">CC</td><td style="text-align: center">delta_s</td><td style="text-align: center">delta_h</td></tr><tr><td style="text-align: center">CG</td><td style="text-align: center">delta_s</td><td style="text-align: center">delta_h</td></tr><tr><td style="text-align: center">GA</td><td style="text-align: center">delta_s</td><td style="text-align: center">delta_h</td></tr><tr><td style="text-align: center">GC</td><td style="text-align: center">delta_s</td><td style="text-align: center">delta_h</td></tr><tr><td style="text-align: center">TA</td><td style="text-align: center">delta_s</td><td style="text-align: center">delta_h</td></tr></table><p><strong>Notes</strong></p><p>This struct is essential for functions aiming to compute the thermodynamics of DNA sequences  or structures.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Phaj.Region" href="#Phaj.Region"><code>Phaj.Region</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Region
    start::Int
    stop::Int
end</code></pre><p>A mutable structure that represents a region in a sequence. <code>start</code> and <code>stop</code> are the  1-based indices of the start and end of the region, respectively.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Phaj.progress_bar_update" href="#Phaj.progress_bar_update"><code>Phaj.progress_bar_update</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Update progress bar on the command line.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Phaj.prpy_sequence" href="#Phaj.prpy_sequence"><code>Phaj.prpy_sequence</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prpy_sequence(sequence::AbstractString)::String</code></pre><p>Convert a given DNA sequence into purine (A/G represented by &#39;R&#39;)  and pyrimidine (C/T represented by &#39;Y&#39;) codes.</p><p><strong>Arguments</strong></p><ul><li><code>sequence::AbstractString</code>: A DNA sequence containing nucleotide bases.</li></ul><p><strong>Returns</strong></p><ul><li>A string where purines are replaced with &#39;R&#39; and pyrimidines with &#39;Y&#39;.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Phaj.sequence_thermodynamic_sum" href="#Phaj.sequence_thermodynamic_sum"><code>Phaj.sequence_thermodynamic_sum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sequence_thermodynamic_sum(delta_h::Vector{Float64}
                            , delta_s::Vector{Float64}
                            , nn_pairs_list::Vector{String}
                            , sequence_nn_list::Vector{String}
                            )</code></pre><p>Calculate the total enthalpy and entropy of each sequence.</p><p><strong>Arguments</strong></p><ul><li><code>delta_h::Vector{Float64}</code>: A vector containing enthalpy values for nearest-neighbor pairs.</li><li><code>delta_s::Vector{Float64}</code>: A vector containing entropy values for nearest-neighbor pairs.</li><li><code>nn_pairs_list::Vector{String}</code>: A vector containing nearest-neighbor pairs.</li><li><code>sequence_nn_list</code>: A list of nearest-neighbor pairs for the given sequence.</li></ul><p><strong>Returns</strong></p><ul><li>Total enthalpy and entropy for the sequence.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Phaj.gc_content" href="#Phaj.gc_content"><code>Phaj.gc_content</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gc_content(sequence::LongSequence{DNAAlphabet{4}})::Float64</code></pre><p>Calculate the GC content of a given DNA sequence.</p><p><strong>Arguments</strong></p><ul><li><code>sequence::LongSequence{DNAAlphabet{4}}</code>: A DNA sequence containing nucleotide bases.</li></ul><p><strong>Returns</strong></p><ul><li>The percentage of G and C bases in the given sequence.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Phaj.sortbyrank" href="#Phaj.sortbyrank"><code>Phaj.sortbyrank</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sortbyrank(i::Int, j::Int, rank::Vector{Int}, k::Int, len::Int) -&gt; Bool</code></pre><p>Determine the ordering of two indices in the suffix array based on their ranks.</p><p>This function is crucial in the construction of the suffix array. It provides a means  to compare two suffixes in the sequence. Initially, the comparison is done based on  the individual characters. As the algorithm progresses and the ranks evolve (becoming  more refined), the comparison can consider characters further down the sequence.</p><p><strong>Arguments</strong></p><ul><li><code>i::Int</code>: The starting index of the first suffix in the sequence.</li><li><code>j::Int</code>: The starting index of the second suffix in the sequence.</li><li><code>rank::Vector{Int}</code>: The rank array corresponding to the current state of suffixes.</li><li><code>k::Int</code>: The offset used to look-ahead in the rank comparisons.</li><li><code>len::Int</code>: The length of the sequence.</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the suffix starting at <code>i</code> comes before the suffix starting at <code>j</code>, <code>false</code> otherwise.</li></ul><p><strong>Notes</strong></p><p>The function considers not just the current rank but also the rank of the characters  <code>k</code> positions ahead in the sequence. This is to ensure the correct ordering of suffixes  that may start with the same characters.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Phaj.build_suffix_array" href="#Phaj.build_suffix_array"><code>Phaj.build_suffix_array</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">build_suffix_array(sequence::String) -&gt; Vector{Int}</code></pre><p>Build a suffix array for a given sequence.</p><p><strong>Arguments</strong></p><ul><li><code>sequence::String</code>: A DNA sequence string.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Vector{Int}</code> representing the suffix array of the sequence.</li></ul><p><strong>Explanation</strong></p><p>The suffix array construction algorithm uses a double-sorting technique based on  ranks of characters and their next &#39;k&#39; characters. These ranks are updated in each  iteration to reflect the combined ranks of two consecutive substrings of length &#39;k&#39;.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Phaj.build_longest_common_prefix" href="#Phaj.build_longest_common_prefix"><code>Phaj.build_longest_common_prefix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">build_longest_common_prefix(sequence::String, suffix_array::Vector{Int}) -&gt; Vector{Int}</code></pre><p>Build the Longest Common Prefix (LCP) array from a sequence and its suffix array.</p><p><strong>Arguments</strong></p><ul><li><code>sequence::String</code>: A DNA sequence string.</li><li><code>suffix_array::Vector{Int}</code>: The suffix array of the sequence.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Vector{Int}</code> representing the LCP array of the sequence.</li></ul><p><strong>Explanation</strong></p><p>The LCP array indicates the number of characters two consecutive suffixes in the  suffix array have in common.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Phaj.find_homodimers" href="#Phaj.find_homodimers"><code>Phaj.find_homodimers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">find_homodimers(sequence::String) -&gt; Vector{String}</code></pre><p>Identify all homodimers in a given DNA sequence using a suffix array and LCP array.</p><p><strong>Arguments</strong></p><ul><li><code>sequence::String</code>: A DNA sequence string.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Vector{String}</code> containing all identified homodimers in the sequence.</li></ul><p><strong>Explanation</strong></p><p>This function aims to identify regions in the provided DNA sequence where the sequence  is its own complement, known as homodimers. To do this, the sequence is combined with  its reverse complement. The reason for using the reverse complement (rather than the  simple complement) is that DNA naturally binds in an antiparallel fashion. In other  words, when looking for a region in the sequence that can form a homodimer (with itself),  it is the reverse complement of a subsequence that will align with and bind to that subsequence.</p><p>It then checks the LCP values to identify overlapping regions between the original  sequence and its complement, which indicate homodimers.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Phaj.filter_probes" href="#Phaj.filter_probes"><code>Phaj.filter_probes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">filter_probes(probes::Vector{String}
                , temperature_threshold::Integer
                , monovalent::Float64
                , mg::Float64
                , dntps::Float64
                , oligo_conc::Float64
                , delta_g_threshold::Float64
                , upper_gc::Float64
                , lower_gc::Float64
                , max_aligned_length::Integer
                , max_heterodimer_tm::Integer
                )</code></pre><p>Filter probes based on the adjusted melting temperature with respect to a temperature threshold.  Calculates the adjusted melting temperature for pairs of sequences and returns those sequences  with temperatures below the given threshold. Additionally, calculates and returns Gibbs free energy  for the aligned region of each sequence pair.</p><p><strong>Arguments</strong></p><ul><li><code>probes::Vector{String}</code>: A vector of DNA sequences (probes) to be filtered.</li><li><code>temperature_threshold::Integer</code>: A temperature threshold (in Celsius) to filter the probes.</li><li><code>monovalent::Int64</code>: Concentration of monovalent ions in mM.</li><li><code>mg::Float64</code>: Concentration of magnesium ions in mM.</li><li><code>dntps::Float64</code>: Concentration of dNTPs in mM.</li><li><code>oligo_c::Float64</code>: Oligo concentration in μM.</li><li><code>delta_g_threshold::Float64</code>: Delta G threshold for homodimer sequences in kcal/mol.</li><li><code>upper_gc::Float64</code>: Upper bound for cutoff based on percent GC, range 0-1.0.</li><li><code>lower_gc::Float64</code>: Lower bound for cutoff based on percent GC, range 0-1.0.</li><li><code>max_aligned_length::Integer</code>: Maximum length of complementary bps a probe can have with other probes.</li><li><code>max_heterodimer_tm::Integer</code>: Maximum melting temperature a stretch of heterodimer bases can have </li></ul><p>with another probe.</p><p><strong>Returns</strong></p><ul><li><code>promising_probes</code>: A set of sequences with adjusted melting temperatures below the temperature threshold.</li></ul><p><strong>Notes</strong></p><p>The function considers various thermodynamic and environmental parameters, such as mono- and divalent ion concentrations,  to calculate adjusted melting temperatures and Gibbs free energy for each sequence pair.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Phaj.check_probe_tm" href="#Phaj.check_probe_tm"><code>Phaj.check_probe_tm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_probe_tm(probe::String
                , temperature_threshold::Integer
                , monovalent::Float64
                , nn::nn_params
                , oligo_c::Float64
                , dntps::Float64
                , mg::Float64
                )</code></pre><p>Check if all slices of a DNA probe sequence have melting temperatures (<code>Tm</code>) above a  set threshold. The function splits the probe into roughly two equal slices and calculates  the <code>Tm</code> for each slice considering corrections for monovalent ions, magnesium ions, and dNTPs.</p><p><strong>Arguments</strong></p><ul><li><code>probe::String</code>: The DNA probe sequence to check.</li><li><code>temperature_threshold::Integer</code>: The minimum required melting temperature in degrees Celsius.</li><li><code>monovalent::Int64</code>: Concentration of monovalent ions in mM.</li><li><code>nn::nn_params</code>: A structure containing the thermodynamic parameters for all possible nearest-neighbor pairs.</li><li><code>oligo_c::Float64</code>: Oligo concentration in μM.</li><li><code>dntps::Float64</code>: Concentration of dNTPs in mM.</li><li><code>mg::Float64</code>: Concentration of magnesium ions in mM.</li></ul><p><strong>Returns</strong></p><ul><li><code>Boolean</code>: <code>true</code> if all slices have a <code>Tm</code> above the temperature threshold, otherwise <code>false</code>.</li></ul><p><strong>Notes</strong></p><p>This function aims to ensure that all subsections of a DNA probe sequence have sufficient  stability (i.e., high melting temperature) to maintain a double-stranded configuration  under specific conditions. It&#39;s crucial when designing probes for applications where uniform hybridization across the probe is desired.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">probe = &quot;AATTATGACTGGGAAAGTAAACCGCCTCCACGTAAGCAAGGAAGGCATTCCAATTGTCGAACGGACTGAAGTTTCGGATA&quot;
threshold = 60
monovalent_concentration = 50
nn_parameters = nn_params()
oligo_concentration = 2 * 1e-6
dNTP_concentration = 0
mg_concentration = 2
result = check_probe_tm(probe
                        , threshold
                        , monovalent_concentration
                        , nn_parameters
                        , oligo_concentration
                        , dNTP_concentration
                        , mg_concentration
                        )</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Phaj.slice_probe" href="#Phaj.slice_probe"><code>Phaj.slice_probe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">slice_probe(probe::String, slice_size::Int) -&gt; Vector{String}</code></pre><p>Get substring slices from a probe of size <code>slice_size</code>.</p><p><strong>Arguments</strong></p><ul><li><code>probe</code>: A string containing the probe sequence to be split.</li><li><code>slice_size</code>: The size of the substring to created. Each probe is divided into chunks of this size (from left to right, and without overlap between chunks).</li></ul><p><strong>Returns</strong></p><p>Returns the substrings of the input probe sequence.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">probe = &quot;CGTGCGCCACTAGACTTGGCAAGGCGTGGAACCGATACCTGCTACCGTGTTAGCAACAAACAGCTATCAACACAGCCATG&quot;
slice_size = 40
probe_slices = slice_probe(probe, slice_size)
2-element Vector{String}:
 &quot;CGTGCGCCACTAGACTTGGCAAGGCGTGGAACCGATACCT&quot;
 &quot;GCTACCGTGTTAGCAACAAACAGCTATCAACACAGCCATG&quot;</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Phaj.calculate_thermodynamic_parameters" href="#Phaj.calculate_thermodynamic_parameters"><code>Phaj.calculate_thermodynamic_parameters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calculate_thermodynamic_parameters(sequence::AbstractString, monovalent::Float64, nn::nn_params)</code></pre><p>Calculate the Gibbs free energy (<code>ΔG</code>), total enthalpy (<code>ΔH</code>), and total entropy (<code>ΔS</code>) of  a given DNA sequence. The computation is based on the nearest-neighbor (NN) model, taking  into account the sequence&#39;s content and a provided monovalent ion concentration.</p><p><strong>Arguments</strong></p><ul><li><code>sequence::AbstractString</code>: A DNA sequence for which thermodynamic parameters will be calculated.</li><li><code>monovalent::Int64</code>: The concentration of monovalent ions in mM.</li><li><code>nn::nn_params</code>: A structure containing the thermodynamic parameters for all possible nearest-neighbor pairs.</li></ul><p><strong>Returns</strong></p><ul><li><code>aligned_delta_g</code>: The Gibbs free energy (<code>ΔG</code>) of the sequence.</li><li><code>sequence_dh_total</code>: The total enthalpy (<code>ΔH</code>) of the sequence, considering both internal </li></ul><p>nearest-neighbor interactions and terminal base pair corrections.</p><ul><li><code>sequence_total_ds</code>: The total entropy (<code>ΔS</code>) of the sequence based on its nearest-neighbor content.</li></ul><p><strong>Notes</strong></p><p>The function uses nearest-neighbor parameters and end compensation (terminal base pair  corrections) to compute the thermodynamics of the DNA sequence. The computed Gibbs free  energy is especially important for predicting the stability of DNA duplexes.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">seq = &quot;AGTCGA&quot;
monovalent_concentration = 50
nn_parameters = nn_params()
ΔG, ΔH, ΔS = calculate_thermodynamic_parameters(seq, monovalent_concentration, nn_parameters)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Phaj.longest_aligned_region!" href="#Phaj.longest_aligned_region!"><code>Phaj.longest_aligned_region!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">longest_aligned_region!(region::Region, alignment_anchors::Vector{AlignmentAnchor})</code></pre><p>Modifies the <code>region</code> object in place to represent the longest aligned region in the given  <code>alignment_anchors</code>.</p><p><strong>Arguments</strong></p><ul><li><code>region::Region</code>: A <code>Region</code> object that will be modified in place. After the function call, </li></ul><p><code>region.start</code> and <code>region.stop</code> will be the start and end indices of the longest aligned  region in the alignment result.</p><ul><li><code>alignment_anchors::Vector{AlignmentAnchor}</code>: The alignment anchors to analyze.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">region = Region(0, 0) 
aln = alignment(alignment_result) 
alignment_anchors = alignment(alignment_result).a.aln.anchors
longest_aligned_region!(region, alignment_anchors)
println(&quot;The longest aligned region is from index(region.start) to index(region.stop)&quot;) </code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Phaj.probe_tm_salt_correction" href="#Phaj.probe_tm_salt_correction"><code>Phaj.probe_tm_salt_correction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">probe_tm_salt_correction(probe_melting_temperature, monovalent, magnesium, dNTPs, probe_gc, probe_length)</code></pre><p>Adjust the provided melting temperature for a DNA probe based on salt and magnesium concentrations in the buffer.</p><p>Uses equations from Owczarzy et al. (2008) to modify the melting temperature according to monovalent ion,  magnesium, and dNTP concentrations. </p><p>Reference: Owczarzy, R., et al. (2008). Biochemistry, <a href="https://doi.org/10.1021/bi702363u">https://doi.org/10.1021/bi702363u</a>.</p><p><strong>Arguments</strong></p><ul><li><code>probe_melting_temperature::Float64</code>: Initial melting temperature (in Celsius) calculated at 1 M salt concentration.</li><li><code>monovalent::Float64</code>: Concentration of monovalent ions (e.g., Na+ or K+).</li><li><code>magnesium::Float64</code>: Concentration of magnesium ions.</li><li><code>dNTPs::Float64</code>: Concentration of dNTPs.</li><li><code>probe_gc::Float64</code>: GC content of the probe as a fraction (0.0-1.0).</li><li><code>probe_length::Int</code>: Length of the DNA probe.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: Adjusted melting temperature (in Celsius).</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Phaj.parse_commandline" href="#Phaj.parse_commandline"><code>Phaj.parse_commandline</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parse_commandline() -&gt; Dict</code></pre><p>Parse and collect command line arguments.</p><p><strong>Description</strong></p><p>This function fetches user-defined parameters for filtering potential DNA hybridization probes. The parameters include monovalent ion concentration, magnesium concentration, dNTP concentration,  probe oligo concentration, reaction temperature, homodimer sequence melting temperature,  delta G threshold, GC content bounds, maximum length of complementary base pairs, and  input/output filenames.</p><p><strong>Returns</strong></p><ul><li>A dictionary containing user-defined parameters.</li></ul><p><strong>Command line arguments:</strong></p><ul><li><code>--mono, -m</code>: Monovalent ion concentration in reaction (default: 50.0 mM).</li><li><code>--mg, -M</code>: Magnesium concentration in reaction (default: 2.0 mM).</li><li><code>--dntps, -d</code>: dNTP concentration in reaction (default: 0.0 mM).</li><li><code>--oligo, -c</code>: Total probe oligo concentration in reaction (default: 0.25 μM).</li><li><code>--temp, -t</code>: Reaction temperature, serving as a melting temperature threshold for probes (default: 65°C).</li><li><code>--heterodimer, -H</code>: Maximum allowed homodimer sequence melting temperature (default: 25°C).</li><li><code>--delta-g, -G</code>: Delta G threshold, below which homodimer sequences are not allowed (default: -10.0).</li><li><code>--upper, -u</code>: Upper bound for percent GC (e.g., 0.7 for 70% GC; default: 0.6).</li><li><code>--lower, -l</code>: Lower bound for percent GC (e.g., 0.45 for 45% GC; default: 0.4).</li><li><code>--max, -L</code>: Maximum length of complementary base pairs a probe can have with other probes (default: 5).</li><li><code>--out, -o</code>: Output filename for a fasta containing promising probes (default: &quot;promising_probes.fa&quot;).</li><li><code>fasta</code>: Input fasta file containing hybridization probes to be filtered (required).</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Get arguements from the command-line
parsed_args = parse_commandline()
for (arg,val) in parsed_args
    println(&quot;  $arg  =&gt;  $val&quot;)
end</code></pre></div></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 25 August 2023 20:51">Friday 25 August 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
